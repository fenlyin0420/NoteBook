
|特性|`vue.config.js` (Vue CLI)|`vite.config.js` (Vite)|
|---|---|---|
|​**构建工具**|基于 Webpack|基于 Vite（使用 Rollup 生产构建）|
|​**开发服务器速度**|较慢（需要打包）|极快（基于 ES 模块按需加载）|
|​**配置文件格式**|CommonJS (`module.exports`)|ES 模块 (`export default`)|
|​**插件系统**|Vue CLI 插件|Vite 插件|
|​**适用场景**|传统项目，需要深度 Webpack 定制|现代项目，追求开发效率和性能|


# vite 配置代理服务器

> 配置代理服务器那里，可以将后端服务器作为代理服务器。
> 之后想要访问后端接口，就不必关心后端接口具体的url了，只需要记住前端自定义的url，剩下的处理交由代理配置，由代理配置转换为后端url再访问。是吗？


是的，**代理服务器**的核心作用正是如此！通过配置代理服务器，前端开发人员可以**屏蔽后端接口的具体 URL**，只需使用前端自定义的 URL，代理服务器会自动将请求转发到后端服务器，并处理跨域等问题。以下是详细的解释和示例：

---

### 1. **代理服务器的作用**
代理服务器在前端和后端之间充当“中间人”的角色，其主要功能包括：
• **隐藏后端 URL**：前端只需使用自定义的 URL（如 `/api`），代理服务器会将其转换为后端实际的 URL。
• **解决跨域问题**：在开发环境中，前端和后端通常运行在不同的域名或端口上，直接请求会触发浏览器的跨域限制。代理服务器可以将请求转发到后端，避免跨域问题。
• **简化开发**：前端开发人员无需关心后端的具体部署地址，只需使用代理配置中定义的路径。

---

### 2. **代理配置示例**
在 Vite 的配置文件中，代理服务器的配置如下：
```typescript
server: {
  proxy: {
    '/api': {
      target: 'http://backend-server.com', // 后端服务器地址
      changeOrigin: true, // 允许跨域
      rewrite: path => path.replace('/api/', '/'), // 重写路径
    },
  },
}
```

#### 配置解析：
• **`/api`**：前端自定义的路径前缀。例如，前端请求 `/api/user`。
• **`target`**：后端服务器的实际地址。例如，`http://backend-server.com`。
• **`changeOrigin`**：设置为 `true`，允许跨域请求。
• **`rewrite`**：重写请求路径。例如，将 `/api/user` 重写为 `/user`。

---

### 3. **实际工作流程**
假设：
• 前端运行在 `http://localhost:5173`。
• 后端运行在 `http://backend-server.com`。

#### 未配置代理时：
前端直接请求后端：
```javascript
fetch('http://backend-server.com/user')
```
• 问题：由于前端和后端域名不同，浏览器会阻止跨域请求。

#### 配置代理后：
前端请求：
```javascript
fetch('/api/user')
```
• 代理服务器会将 `/api/user` 转换为 `http://backend-server.com/user`，并转发请求。
• 前端无需关心后端的具体地址，只需使用 `/api` 作为前缀。

---

### 4. **优点**
• **简化开发**：前端开发人员只需使用代理配置中定义的路径，无需修改代码即可切换后端地址。
• **解决跨域问题**：代理服务器可以避免浏览器的跨域限制。
• **灵活性**：通过修改代理配置，可以轻松切换后端环境（如开发、测试、生产）。

---

### 5. **注意事项**
• **仅适用于开发环境**：Vite 的代理配置仅在开发环境中生效。在生产环境中，需要通过其他方式（如 Nginx）配置代理。
• **路径匹配**：确保代理配置的路径前缀（如 `/api`）与前端请求的路径一致。
• **环境变量**：可以将后端地址配置为环境变量，便于在不同环境中切换。

---

### 6. **总结**
通过配置代理服务器，前端可以**屏蔽后端的具体 URL**，只需使用自定义的路径（如 `/api`），代理服务器会自动将请求转发到后端服务器，并处理跨域等问题。这种方式不仅简化了开发流程，还提高了代码的可维护性和灵活性。