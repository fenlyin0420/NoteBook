在算法竞赛中，**合理选择算法时间复杂度**是是否能通过评测的关键因素。

下面是一个常用的 **「数据规模 vs 可接受时间复杂度」对照表**，你可以作为刷题时估算是否超时的参考👇

---

## 🚀 数据规模与时间复杂度对照表

|数据规模 n|可接受的最大时间复杂度（大致）|
|---|---|
|≤ 10|`O(n!)`、`O(2^n)` 级别（全排列、回溯）|
|≤ 15|`O(2^n * n)`（状压 DP、DFS + 剪枝）|
|≤ 20~25|`O(2^n)`（组合子集、状压、回溯）|
|≤ 100|`O(n^4)`、`O(n^3)`（暴力三重循环）|
|≤ 500|`O(n^3)`（Floyd、三重循环）|
|≤ 1,000|`O(n^2)`（DP、两重循环、简单图算法）|
|≤ 5,000|`O(n^2)`（较快的实现也能过）|
|≤ 10^4|`O(n * √n)`（分块、根号优化等）|
|≤ 10^5|`O(n log n)`（排序、线段树、树状数组、并查集等）|
|≤ 10^6|`O(n)`（计数、哈希、前缀和、双指针等）|
|≤ 10^7|`O(n)`（需注意常数，代码必须非常快）|
|≤ 10^8|`O(1)` 或极快常数的 `O(n)`|

💡 **一般评测时间限制是 1 秒 ~ 2 秒**，1 秒能运行大约 **1e8 次操作**（依平台而异，建议按 1e7 保守估算）。

---

## 🧠 一些典型例子

|算法 / 技术|时间复杂度|适用数据规模|
|---|---|---|
|全排列 / 回溯|`O(n!)`|n ≤ 9~10|
|二进制子集枚举|`O(2^n)`|n ≤ 20~22|
|Floyd 全源最短路|`O(n^3)`|n ≤ 300~500|
|双重循环 DP（LCS）|`O(n^2)`|n ≤ 1000|
|Dijkstra / 最小生成树（堆）|`O((n + m) log n)`|n, m ≤ 10^5|
|排序、优先队列|`O(n log n)`|n ≤ 1e5~1e6|
|KMP / 双指针|`O(n)`|n ≤ 1e6|
|素数筛（线性筛）|`O(n)`|n ≤ 1e7|
|并查集优化（路径压缩）|近似 `O(α(n))`|n ≤ 1e5~1e6|

---

## ✅ 常用经验口诀

- **1 秒内允许约 1e7 次操作，2 秒约 2e7~1e8**。
    
- 遇到 **n ≤ 1e5**，就考虑 `O(n log n)` 以内的算法（比如排序、树状数组等）。
    
- 遇到 **n ≤ 1e3**，可尝试 `O(n^2)` 的 DP。
    
- n ≤ 20：放心地写爆搜、回溯、状压。
    
- 提交前可粗估代码复杂度，防止超时！
    

---

## 📌 附加技巧：降低常数时间

即使复杂度合适，**过大的常数因子**（如 STL 滥用、多次拷贝、递归层数深）也可能 TLE（超时）：

- 用 `scanf/printf` 替代 `cin/cout`
    
- 用 `unordered_map` 或数组代替 `map`
    
- 减少不必要的函数调用、对象拷贝
    
- 注意爆栈（DFS 太深、递归层数 > 1e5）
